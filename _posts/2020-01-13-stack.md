---
layout: post
title:  "스택 Stack"
---

> 이 글은 Udemy의 [Data Structures & Algorithms !](https://www.udemy.com/course/learn-data-structure-algorithms-with-java-interview/) 강의를 바탕으로 작성했습니다.

### 스택이란?
**LIFO** (Last In First Out) 를 따르는 자료구조이다. 맨 먼저 낀 팔찌는 맨 나중에 뺄 수 있고, 맨 나중에 낀 팔찌를 맨 먼저 빼야 하는 상황을 생각하면 된다. 또는 브라우저에서 앞/뒤로 가는 버튼을 떠올릴 수도 있다.

### 스택의 기본 연산
* create
* push
* pop
* peek
* isEmpty
* isFull
* delete

### 스택의 구현
스택을 구현하는 방법에는 2가지 옵션이 있다.
1. 배열을 사용한 구현
* 장점: 상대적으로 구현하기 쉽다.
* 단점: 크기가 고정되어 있다.
2. 연결 리스트를 사용한 구현
* 장점: 크기가 가변적이다.
* 단점: 상대적으로 구현하기 어렵다.

### 배열로 구현하기

#### create
```
CreateStack(int size):
    create blank array of 'size'
    initialize variable 'topOfStack' // 스택의 맨 위에 있는 셀을 가리킴
```
* 시간 복잡도: O(1)
* 공간 복잡도: O(n)

#### push
스택의 맨 앞에 요소를 추가하는 연산.
```
push(value):
    if stack is full
        return error
    else
        insert 'value' at the top of the array
        topOfStack++
```
* 시간 복잡도: O(1)
* 공간 복잡도: O(1)

#### pop
스택이 비어 있지 않다면, 맨 위의 요소를 제거한다.
```
pop():
    if stackIsEmpty()
        return error
    else
        print top of stack
        topOfStack--
```
* 시간 복잡도: O(1)
* 공간 복잡도: O(1)

#### peek
스택 맨 위의 요소를 제거하지는 않고 확인만 하는 연산.
```
peek():
    if stackIsEmpty()
        return error
    else
        return topOfStack
```
* 시간 복잡도: O(1)
* 공간 복잡도: O(1)

#### isEmpty
```
isEmpty():
    if (topOfStack is -1)
        return true
    else
        return false
```
* 시간 복잡도: O(1)
* 공간 복잡도: O(1)

#### isFull
```
isFull():
    if (topOfStack equals arr.size)
        return true
    else
        return false
```
* 시간 복잡도: O(1)
* 공간 복잡도: O(1)

#### delete
```
deleteStack():
    arr = null
```
* 시간 복잡도: O(1)
* 공간 복잡도: O(1)

### 연결 리스트로 구현하기

#### create
비어 있는 (`null`값을 가진) 헤드를 만든다.
```
createStack():
    create an object of SingleLinkedList // only create a blank(NULL) head!!
```
* 시간복잡도: O(1)
* 공간복잡도: O(1)

#### push
```
push(nodeValue):
    create a node
    node.value = nodeValue
    node.next = header
    header = node
```
* 아하 노드를 만들고, 처음 노드는 NULL(당시의 헤드 값)을 가리키지만 그 다음에 넣는 노드의 next는 이전 노드(그 때는 그게 헤드니까)를 가리키고 그 다음에 헤드를 이제 새 노드로 업데이트하는구나! 즉 헤드는 항상 가장 최신의 노드를 가리키고 있고 각 노드의 next는 자기 바로 아래에 있는 노드임
* 시간복잡도: O(1)
* 공간복잡도: O(1)

#### pop
```
pop():
    if isEmpty()
        return error
    else
        tmpNode = header
        header = header.next
        return tmpNode.value
```
* 시간복잡도: O(1)
* 공간복잡도: O(1)

#### peek
```
peek():
    return header.value
```
* 시간복잡도: O(1)
* 공간복잡도: O(1)

#### isEmpty

```
isEmpty():
    if (header equals null)
        return true
    else
        return false
```
* 시간복잡도: O(1)
* 공간복잡도: O(1)

#### isFull
연결 리스트로 구현한 스택은 노드의 추가와 삭제가 가능하므로 `isFull`연산이 필요하지 않다.

#### delete

```
deleteStack():
    header = null
```
* 시간복잡도: O(1)
* 공간복잡도: O(1)

### 언제 스택을 써야 할까?

* 데이터를 특정한 방식으로 (LIFO) 다룰 필요가 있을 때
* 중간에 있는 요소에 접근할 수 없다는 장점이자 단점이 있다. 외부에서 쉽게 데이터를 변경할 수 없다는 것은 장점이지만, 중간에 있는 요소에 실수가 있었다면 바로잡기가 번거롭다.

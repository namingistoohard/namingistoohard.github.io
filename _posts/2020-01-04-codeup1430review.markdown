1430 : 기억력 테스트 2
시간 제한: 2 Sec   메모리 제한: 128 MB


주현이 엄마는 주현이를 영재로 키우기 위해 매일 혹독한 기억력 테스트를 하고 있다.

N개의 숫자를 먼저 말해주고, M개의 질문을 하면서 그 숫자가 있었는지 없었는지 테스트한다.

만약 있었다면 1을 출력하고, 없었다면 0을 출력한다.

이번에는 주현이가 좋아하는 3단 합체 변신로봇 '또봇 트라이탄'이 선물로 걸려있다.

주현이를 도와 줄수 있는 프로그램을 만드시오.

입력 예시   
5
2 52 23 55 100
4
5 2 55 99

출력 예시
0 1 1 0 


-------------------------------

이 문제는 1차원 배열 기초 문제로, 기존 숫자 배열에 질문한 숫자가 있는 확인해주고 0와 1 로 출력을 하는 간단한 문제이다.
하지만 역시 시간초과나 메모리초과가 발생했다.

일단 첫 배열의 크기가 m, 두번째 배열의 크기가 n 일 때 O(n^2)의 시간이 걸린다. m의 크기 제한은 10,000,000이므로 상당히 긴 시간이다.

마지막으로 채점된 결과는 배열 크기 초과였다.


```java
import java.util.*;
import java.lang.*;

public class Main{
    public static void main(String[] args)throws Exception{
        Scanner sc = new Scanner(System.in);
        String n0 = sc.nextLine();
        int n = Integer.parseInt(n0);
        String s = sc.nextLine();
        String[] s2 = s.split(" ");
        ArrayList<Integer> map = new ArrayList<>();
        for(int i=0; i<n; i++){
            int k = Integer.parseInt(s2[i]);
            if(map.get(k)!=null){
                continue;
            }
            map.add(k);
        }
        String m = sc.nextLine();
        String m2 = sc.nextLine();
        String [] m2l = m2.split(" ");
        for(int i=0; i<Integer.parseInt(m); i++){
            int k = Integer.parseInt(m2l[i]);
            
            if(map.get(k)!=null){
                System.out.print(1+" ");
            }else{
                System.out.print(0+" ");
            }
        }
    }
    
    
}
```
이 코드는 시간복잡도를 줄이기 위해 map으로 어레이리스트를 만들고 넣어준뒤 질문을 해당 맵에서 검색하면서 결과를 출력한다.
하지만 49줄 map.get(k) != null에서 배열의 길이를 초과했다는 오류가 뜬다. 이는 중복값을 판단하는 것인데 map에 포함되지 않는 요소를
map.get() 함수로 찾으려 할때의 결과값이 null과 비교할 수 없는 것 같다. map을 arraylist 로 만들었기 때문에 여기서의 get은 인덱스 였던 것이다. 

```java
Exception in thread "main" java.lang.IndexOutOfBoundsException: Index: 5, Size: 5
	at java.util.ArrayList.rangeCheck(ArrayList.java:657)
	at java.util.ArrayList.get(ArrayList.java:433)
	at Main.main(Main.java:45)
```

그런데 찾아보던 중 다른 풀이를 발견했다. 공간복잡도를 키우고 시간복잡도를 줄이는 방법이다.

```
import java.util.*;
import java.lang.*;
import java.io.*;

public class Main{
    public static void main(String[] args)throws Exception{
        
        
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String s = bf.readLine();
        int n = Integer.parseInt(s);
        s = bf.readLine();
        String[] s2 = s.split(" ");
        
        
        int max = 0;
        for(int i=0; i<n; i++){
            int k = Integer.parseInt(s2[i]);
            if(max<k){
                max = k;
            }
        }
        int [] arr = new int[max+1];
        for(int i=0; i<n; i++){
            int k = Integer.parseInt(s2[i]);
            arr[k] = 1;
        }

        String m = bf.readLine();
        String m2 = bf.readLine();
        String [] m2l = m2.split(" ");
        
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
      
        for(int i=0; i<Integer.parseInt(m); i++){
            int k = Integer.parseInt(m2l[i]);
            if(k>max){
                bw.write(0+" ");
                continue;
            }
            if(arr[k]!=0){
                bw.write(1+" ");
            }else{
                bw.write(0+" ");
            }
        }
        bw.flush();
        bw.close();
    }
    
    
}
```
그러나 공간복잡도가 너무 커져서 메모리 초과가 났다.
그렇다면 다시 해시맵을 사용해서 get으로 찾으려 했지만..

```
import java.util.*;
import java.lang.*;
import java.io.*;

public class Main{
    public static void main(String[] args)throws Exception{
        
        
        BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));
        String s = bf.readLine();
        int n = Integer.parseInt(s);
        s = bf.readLine();
        String[] s2 = s.split(" ");
        
        HashMap<Integer,Integer> hashMap = new HashMap<>();  

        for(int i=0; i<n; i++){
            int k = Integer.parseInt(s2[i]);
            hashMap.put(k,1);
        }

        String m = bf.readLine();
        String m2 = bf.readLine();
        String [] m2l = m2.split(" ");
        
        BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
      
        for(int i=0; i<Integer.parseInt(m); i++){
            int k = Integer.parseInt(m2l[i]);
            if(hashMap.get(k)!=null){
                bw.write(1+" ");
            }else{
                bw.write(0+" ");
            }
        }
        bw.flush();
        bw.close();
    }
    
    
}
```

역시 메모리 초과가 났다!! 게시판을 보니 자바에는 문제가 많다는 글들이 많다.
c++로 1차원 1000001 의 배열을 만들어서 푼 풀이는 문제없이 정답으로 취급된다..
자바를 버려야겠다는 생각이들었다!

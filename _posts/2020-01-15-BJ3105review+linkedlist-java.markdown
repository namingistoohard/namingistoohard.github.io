<h1> 링크드 리스트와 3105 벽 쌓기 문제 </h1>

<h2>링크드 리스트</h2>
자바에는 링크드 리스트라는 개념이 있다.
오브젝트가 다음 오브젝트를 향하고 있어서 줄줄이 엮는게 가능하다.
수도코드는 이렇다.

일단 하나의 오브젝트 노드가 있고

```java
class node{
  object data;
  node next;
}
```

노드들의 일련인 링크드리스트가 있다.

```java

class linkedlist{
  node front;
  int size;
  
  public put(){}
  ...
}

```

리스트의 첫 노드나 사이즈를 주로 갖고 있다.
추가나 삭제, 편집등의 메소드를 넣는다.

자바에는 이러한 리스트인터페이스가 이미 있다. (linkedlist, arraylist . . .)
여기서 링크드리스트와 어레이리스트 둘은 차이가 있다.

참고: ttps://www.holaxprogramming.com/2014/02/12/java-list-interface

링크드 리스트는 앞서 설명한 방식으로 작동한다. 추가 삭제는 쉽지만 인덱싱은 순회를 많이 해야한다.
어레이 리스트는 배열을 이용해 매번 배열을 새로 만들고 복사해 넣기 때문에 인덱싱은 빠르지만 추가 삭제는 성능저하를 일으키기 쉽다.

<h2>벽 쌓기 문제</h2>



동규는 큰 벽을 2일동안 만들려고 한다.

가게에는 N종류의 블록이 있다. 이 블록의 개수는 매우 많기 때문에, 품절되는 경우는 없다. 각 블록의 가격은 Ci이며, 1*1*Di 크기이다.

2일 중 하루는 모든 블록을 수평으로 쌓을 것이고, 다른 날에는 수직으로 쌓을 것이다.

벽은 L미터 크기의 평평한 땅 위에 만들 것이다. 벽은 실루엣으로 묘사한다.

실루엣은 (x1, y1), (x2, y2), ..., (Xm, Ym)와 같이 좌표의 연속으로 표현하고, 벽의 위쪽 경계선이다.

실루엣에 대해서 좀 더 자세히 설명하면 다음과 같다.

M은 짝수이다.

x1 = 0, xm = L

x2k-1 < x2k, x2k = x2k+1

y2k-1 = y2k

예를 들어, 길이가 7인 벽이 있을 때, 왼쪽 그림을 실루엣으로 표현하면, (0,2), (3,2), (3,1), (5,1), (5,3), (7,3)이며, 오른쪽 그림은 (0,4), (2,4), (2,6), (7,6)이다.








![break](https://www.acmicpc.net/upload/images/block.png)
현재 가게에서 파는 블록의 정보와 첫째 날 완성한 벽의 실루엣과 둘째 날 완성한 벽의 실루엣이 주어졌을 때, 벽을 완성하는데 필요한 금액의 최솟값을 구하는 프로그램을 작성하시오.



--------------------------------

1. 2일동안 만든다.

2. 블록은 무한하다.

3. 블록의 모양은 한가지 변수에 의해서만 변한다. 

4. 하루는 수평, 하루는 수직

5. x2k = x2k+1, y2k-1= y2k 이다.

6. 실루엣은 벽의 위쪽 경계선이다.


----------------------------------------------------------------------------

실루엣이 주어졌을때, 해당좌표를 통해 채워야하는 가로와 세로의 크기를알아낸다.
그리고 y값이 가장 낮은 좌표가 벽돌이 틈틈이 채워진 높이이다. 이것을 실루엣 높이라고 하겠다.
빈틈없이 채워진 구간을 구하기 위해선 실루엣높이 x 한 줄의 벽돌을 수평으로 채울때 한줄에 드는 최소비용을 구하면 된다.


```
class 벽돌{
  int 가격
  벽돌 다음벽돌
}
```
우선 한줄의 길이를 완성할 수 있는 리스트들을 만든다.
그리고 각 벽돌이 가진 가격들의 합이 가장 작은 리스트를 구해낸다.

그럼 실루엣높이 만큼의 벽돌의 가격은 구해졌다.
그다음은, x의 값이 중복되기 전 만큼의 길이에 대해서 위와 같이 최소값을 구해주고,
x의값이 얼마나 중복되는지에 따라서 해당 길이만큼의 높이의 가격을 더해준다.
y의 값이 중복되는 구간부터는 다시 위의 처리를 해준다.

흠 근데 여기까지 생각했는데 만약 x의 값이 중복되면서 y의 값이 커지면??

다시생각해보자!!

실루엣을 모두 받아서 소팅한 후, 한쪽으로 몰아줄 수 있다면?
그럼 각 계단의 길이만큼의 연산을 해주면 된다.

이 방법이 더 좋을까?

수직의 경우에도 비슷한 연산을 취해주면 될 것이다..

여기까지 생각 한 후 풀이를 찾아보았다.

그러나! 풀이가 없었기 때문에 다음에 코드로 풀어보아야 겠다.




